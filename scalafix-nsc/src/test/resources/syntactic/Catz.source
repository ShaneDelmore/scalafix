rewrites = [Catz]
<<< fix imports
import cats.kernel.Eq
import cats.kernel.instances.int._

object autogeneratedkeys {

  /** @group Implementation */
  sealed abstract class AutoGeneratedKeys(val toInt: Int)

  /** @group Values */ case object ReturnGeneratedKeys extends AutoGeneratedKeys(???)
  /** @group Values */ case object NoGeneratedKeys extends AutoGeneratedKeys(???)

  /** @group Implementation */
  object AutoGeneratedKeys {

    def fromInt(n: Int): Option[AutoGeneratedKeys] =
      Some(n) collect {
        case ReturnGeneratedKeys.toInt => ReturnGeneratedKeys
        case NoGeneratedKeys.toInt => NoGeneratedKeys
      }

    def unsafeFromInt(n: Int): AutoGeneratedKeys =
      fromInt(n).get

    implicit val EqualAutoGeneratedKeys: Eq[AutoGeneratedKeys] =
      Eq.by(_.toInt)

  }

}
>>>
import scalaz.Equal
import scalaz.std.anyVal.intInstance

object autogeneratedkeys {

  /** @group Implementation */
  sealed abstract class AutoGeneratedKeys(val toInt: Int)

  /** @group Values */ case object ReturnGeneratedKeys extends AutoGeneratedKeys(???)
  /** @group Values */ case object NoGeneratedKeys extends AutoGeneratedKeys(???)

  /** @group Implementation */
  object AutoGeneratedKeys {

    def fromInt(n: Int): Option[AutoGeneratedKeys] =
      Some(n) collect {
        case ReturnGeneratedKeys.toInt => ReturnGeneratedKeys
        case NoGeneratedKeys.toInt => NoGeneratedKeys
      }

    def unsafeFromInt(n: Int): AutoGeneratedKeys =
      fromInt(n).get

    implicit val EqualAutoGeneratedKeys: Equal[AutoGeneratedKeys] =
      Equal.equalBy(_.toInt)

  }

}
<<< Functor
import cats.Functor
import cats.instances.list._
import cats.instances.option._

object FunctorEx1 {

  val listOption = List(Some(1), None, Some(2))
  // listOption: List[Option[Int]] = List(Some(1), None, Some(2))

  // Through Functor#compose
  Functor[List].compose[Option].map(listOption)(_ + 1)

}
>>>
import scalaz.Functor
import scalaz.std.list._
import scalaz.std.option._

object FunctorEx1 {

  val listOption = List(Some(1), None, Some(2))
  // listOption: List[Option[Int]] = List(Some(1), None, Some(2))

  // Through Functor#compose
  Functor[List].compose[Option].map(listOption)(_ + 1)

}
<<< Semigroup
import cats.Semigroup

object SemigroupEx1 {

  implicit val intAdditionSemigroup: Semigroup[Int] = new Semigroup[Int] {
    def combine(x: Int, y: Int): Int = x + y
  }

}
>>>
import scalaz.Semigroup

object SemigroupEx1 {

  implicit val intAdditionSemigroup: Semigroup[Int] = new Semigroup[Int] {
    def append(x: Int, y: Int): Int = x + y
  }

}
