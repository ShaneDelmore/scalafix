rewrites = [Xor2Either]
<<< xor 1
import scala.concurrent.Future
import cats.data.{ Xor, XorT }
trait A {
type MyDisjunction = Xor[Int, String]
  val r: MyDisjunction = Xor.Right.apply("")
  val s: Xor[Int, String] = cats.data.Xor.Left(1 /* comment */)
  val t: Xor[Int, String] = r.map(_ + "!")
  val nest: Seq[Xor[Int, cats.data.Xor[String, Int]]]
  val u: XorT[Future, Int, String] = ???
}
>>>
import cats.data.EitherT
import cats.implicits._
import scala.util.Either
import scala.concurrent.Future
import cats.data.{ Xor, XorT }
trait A {
type MyDisjunction = Either[Int, String]
  val r: MyDisjunction = Right("")
  val s: Either[Int, String] = Left(1 /* comment */)
  val t: Either[Int, String] = r.map(_ + "!")
  val nest: Seq[Either[Int, Either[String, Int]]]
  val u: EitherT[Future, Int, String] = ???
}
<<< xor do not modify when not present
import scala.concurrent.Future
trait A {
  val num = 1
}
>>>
import scala.concurrent.Future
trait A {
  val num = 1
}
<<< tpe rox
object a{
  val r = cats.data.Xor.right[Int, String]("")
}
>>>
object a {
  val r = cats.data.Xor.right[Int, String]("")
}
<<< cornichonError
import java.io.{ PrintWriter, StringWriter }
import scala.util.control.NoStackTrace
trait CornichonError extends Exception with NoStackTrace {
  def msg: String

  override def getMessage = msg
}
object CornichonError {
  def genStacktrace(exception: Throwable) = {
    val sw = new StringWriter()
    val pw = new PrintWriter(sw)
    exception.printStackTrace(pw)
    sw.toString
  }
  def fromThrowable(exception: Throwable): CornichonError = exception match {
    case ce: CornichonError ⇒ ce
    case _                  ⇒ StepExecutionError(exception)
  }
}
case class StepExecutionError[A](e: Throwable) extends CornichonError {
  val msg = s"exception thrown '${CornichonError.genStacktrace(e)}'"
}
>>>
import scala.util.control.NoStackTrace
